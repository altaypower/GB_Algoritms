"""
Урок 4. Задача 2.
Написать два алгоритма нахождения i-го по счёту простого числа.
    Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число.
    Проанализировать скорость и сложность алгоритмов.
Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
 Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.
"""
from timeit import timeit
# python --version 3.9.0
"""
«Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков».
Я постарался создать свою собственную реализацию «Решета Эратосфена».
Потому что разрабатывать код самому интереснее и полезно для практики.
"""


# моя реализация решета Эратосфена
def eratosfen(i):
    """
    :param i: на вход подается положительное число больше нуля вводимое пользователем
    :return: возвращать будем i-e по счету простое число
    """
    n = i   # для генерации списка
    num_sim = 0    # сюда будем помещать искомое значение
    if i < 1:
        """
        Если пользователь укажет число меньше единицы,
        тогда выдаем сообщение, что введенное значение невалиднно
        """
        return f'Введено неверное значение'
    elif i == 1:
        """
        если пользователь ввел единицу, тогда первое простое число равно двум,
        и смыла в алгоритме нет.
        """
        num_sim = 2
        return f'{i}-е по порядку простое число = {num_sim}'
    else:
        lst = [el for el in range(2, n * 20) if el % 2 != 0]  # здесь у нас сложность O(n)
        """
        Создаем список, количество элементов которого больше значения i в двадцать раз,
        что достаточно для нахождения 20000 простых чисел и более,
        при этом сразу отсеиваем все четные числа.
        Первое простое число равное 2, также исключаем, так как 
        его мы возвращаем в случае i равного 1(одному)
        """
        # print(lst)   # -- исходный список
        j = 1
        simple_arr = [2]
        for n in lst:
            simple_arr.append(n)
            for el in lst[j:]:
                """
                Берем элемент n и отсеиваем все числа кратные ему.
                При этом нам нет необходимости рассматривать элементы
                левее элемента n и сам этот элемент, поэтому используем срез,
                стартовым значением которого берем значение j, увеличивая
                его на единицу после каждого прохождения вложенного цикла.
                """
                if el % n == 0:
                    ndx = lst.index(el)
                    lst.pop(ndx)
            j += 1
            if len(simple_arr) == i:
                break
    num_sim = simple_arr[i - 1]
    return f'{i}-е по счету простое число = {num_sim}'


i_10 = 10
i_20 = 20
i_100 = 100
i_500 = 500
i_1000 = 1000
i_10000 = 10000

# анализируем код

print(eratosfen(i_10))
print('Время для поиска 10го простого числа составило:')
print(
    timeit(
        "eratosfen(i_10)",
        setup="from __main__ import eratosfen, i_10",
        number=100
    )
)

print()
print(eratosfen(i_20))
print('Время для поиска 20го простого числа составило:')
print(
    timeit(
        "eratosfen(i_20)",
        setup="from __main__ import eratosfen, i_20",
        number=100
    )
)

print()
print(eratosfen(i_100))
print('Время для поиска 100го простого числа составило:')
print(
    timeit(
        "eratosfen(i_100)",
        setup="from __main__ import eratosfen, i_100",
        number=100
    )
)

print()
print(eratosfen(i_500))
print('Время для поиска 500го простого числа составило:')
print(
    timeit(
        "eratosfen(i_500)",
        setup="from __main__ import eratosfen, i_500",
        number=100
    )
)

print()
print(eratosfen(i_1000))
print('Время для поиска 1000го простого числа составило:')
print(
    timeit(
        "eratosfen(i_1000)",
        setup="from __main__ import eratosfen, i_1000",
        number=100
    )
)


"""
10-е по счету простое число = 29
Время для поиска 10го простого числа составило:
0.006034499999999998

20-е по счету простое число = 71
Время для поиска 20го простого числа составило:
0.0176867

100-е по счету простое число = 541
Время для поиска 100го простого числа составило:
0.29871339999999996

500-е по счету простое число = 3571
Время для поиска 500го простого числа составило:
6.9450228

1000-е по счету простое число = 7919
Время для поиска 1000го простого числа составило:
27.4868442

"""


def issimple(i):
    n_simp = 2
    j = 1
    if i < 1:
        return f'Введено неверное значение'
    elif i == 1:
        return f'{i}-е по счету простое число равно {n_simp}'
    else:
        while j < i:
            n_simp += 1
            m = 2
            while m < n_simp:
                if n_simp % m == 0:
                    break
                else:
                    m += 1
            if m == n_simp:
                j += 1
    return f'{i}-е по счету простое число равно {n_simp}'


# анализируем алгоритм "без решета"

print(issimple(i_10))
print('Время для поиска 10го простого числа составило:')
print(
    timeit(
        "issimple(i_10)",
        setup="from __main__ import issimple, i_10",
        number=100
    )
)

print()
print(issimple(i_20))
print('Время для поиска 20го простого числа составило:')
print(
    timeit(
        "issimple(i_20)",
        setup="from __main__ import issimple, i_20",
        number=100
    )
)

print()
print(issimple(i_100))
print('Время для поиска 100го простого числа составило:')
print(
    timeit(
        "issimple(i_100)",
        setup="from __main__ import issimple, i_100",
        number=100
    )
)

print()
print(issimple(i_500))
print('Время для поиска 500го простого числа составило:')
print(
    timeit(
        "issimple(i_500)",
        setup="from __main__ import issimple, i_500",
        number=100
    )
)

print()
print(issimple(i_1000))
print('Время для поиска 1000го простого числа составило:')
print(
    timeit(
        "issimple(i_1000)",
        setup="from __main__ import issimple, i_1000",
        number=100
    )
)

"""
10-е по счету простое число равно 29
Время для поиска 10го простого числа составило:
0.0012810000000000009

20-е по счету простое число равно 71
Время для поиска 20го простого числа составило:
0.0055511

100-е по счету простое число равно 541
Время для поиска 100го простого числа составило:
0.18892930000000002

500-е по счету простое число равно 3571
Время для поиска 500го простого числа составило:
5.9702203

1000-е по счету простое число равно 7919
Время для поиска 1000го простого числа составило:
27.5200783


"""

i_3000 = 3000
print(
    timeit(
        "eratosfen(i_3000)",
        setup="from __main__ import eratosfen, i_3000",
        number=100
    )
)
# результат 247.82019710000003

print(
    timeit(
        "issimple(i_3000)",
        setup="from __main__ import issimple, i_3000",
        number=100
    )
)
# результат 298.11739329999995

"""
Вывод: при i > 3000 алгоритм "без решета" начинает проигрывать по времени.
 при i < 3000 время выполнения алгоритмов примерно одинаково.
 Поэтому для поиска i-го простого числа лучше применять алгоритм "Решето Эратосфена"
 особенно при больших значениях i
"""